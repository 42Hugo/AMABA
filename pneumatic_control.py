#for the socket com with C
import socket
import select
import subprocess
import time

class Pneumatic:
    """
    This Python class is designed to start a C subprocess that handles EtherCAT communication using the EtherLab master. 
    Strings are transmitted through sockets from this module.
    """

    def __init__(self):
        """
        The constructor method,  comunication with EtherCAT is also started

        .. note::
            There is no control command for (c_point) as it maintains a fixed pressure between 4.7 and 7 bar to open the nozzle
    

        :param st_cart: set to 1 to open, 0 to close the solenoid valve on fluid, defaults to 0
        :type st_cart: int
        :param st_ato: set to 1 to open, 0 to close the solenoid valve on atomisation (to spay the liquid), defaults to 0
        :type st_ato: int
        :param st_point: set to 1 to open, 0 to close the solenoid valve on nozle (if closed atomization still works but no liquid is spayed), defaults to 0
        :type st_point: int
        :param c_cart: pressure applied to the fluid between 0 and 2 bar (1 decimal possible), defaults to 0
        :type c_cart: float
        :param c_ato: pressure applied to the atomisation between 0 and 2 bar (1 decimal possible), defaults to 0
        :type c_ato: float
        :param connected: indicates whether communication with the subprocess is established (``self.connected = 2`` when running), defaults to 0
        :type connectd: int
        :param filePath: path to the gcode file, defaults to ''
        :type filePath: str
        :param host: Hostname for the socket connection, defaults to 'localhost'
        :type host: str
        :param port: Port number for the socket connection, defaults to 12345
        :type port: int
        """
        #st 0 ou 1 pour controller les vannes
        self.st_cart=0
        self.st_ato=0
        self.st_point=0

        #c pour controler la valeur envoyé à la vanne en bar
        self.c_cart=0 #entre 0 et 2
        self.c_ato=0 #entre 0 et 2
        #no need of c_point as it is a constant pressure to open or close

        #the g-code file path
        self.filePath=""
    
        self.host = 'localhost'
        self.port = 12345
        self.connected=0

        #start c process and socket communication
        self.start_connection()
    
    
    def start_connection(self):                
        """
        start the c process and start socket comunication
        connected will be incremented 

        .. note::
            The path to the `ec_user_example` executable might need to be adjusted. It is generated by `main.c` and handles communication using the EtherCAT protocol.
        
        """
        try:
            #launch the c process
            self.process = subprocess.Popen(['/home/amaba/Desktop/dev_ws/ighEthercat/ethercat/examples/user/ec_user_example'],  stdin=subprocess.PIPE)
            time.sleep(1)#wait here to let the c process initiate
            self.connected+=1
        except:
            print("An error occured when trying to start c_process")
        
        try:
            #laucn socket
            self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            # Connect to the server
            self.client.connect((self.host, self.port))
            self.connected+=1
        except:
            print("An error occured when trying to start the socket")

    def stop_c_program(self):
        """
        Stops both the C process and the socket communication.
        """
        self.sendToClient(0) #turn everything off before switch off
        # Terminate the C program
        self.process.terminate()
        self.process.wait()
        self.client.close()  

    def sendToClient(self,state):       
        """
        Gathers all pressure-related information and sends it to the C process in the appropriate string format.

        The `state` argument is always set to 1, except when terminating the process. 
        
        The string format is as follows:
         - The first bit indicates the state (1 or 0). A state of 0 will automatically terminate the loop.
         - Bits 2, 3, and 4 are for the solenoid valve: 0 for closed, 1 for open.
         - Bits 5, 6, 7, and 8 represent the pressure values (between 0 and 2) for atomization and fluid, without a comma.

        The string should look like this:

        .. code-block:: python

            mes = '[state][on/off atomization][on/off fluid][on/off nozzle][pressure atomization between 0 and 20][pressure fluid between 0 and 20]'

        For example, consider the following string:

        .. code-block:: python

            mes = '10001103'

        - The state is on (1).
        - All three solenoids are closed (0 for atomization, fluid, and nozzle).
        - 1.1 bar for atomization.
        - 0.3 bar for fluid.
        
        :param state: State of the process, 1 for running, 0 for stopping
        :type state: int
        """

        self.presAto= int(self.c_ato*10)
        if (self.presAto<10):
            presAtostr="0"+str(self.presAto)
        elif (self.presAto==0):
            presAtostr="00"
        else:
            presAtostr=str(self.presAto)
        presCart= int(self.c_cart*10)
        if (presCart<10):
            presCartstr="0"+str(presCart)
        elif(presCart==0):
            presCart="00"
        else:
            presCartstr=str(presCart)
        mes = str(state) +  str(self.st_ato) + str(self.st_cart)+ str(self.st_point)  +presAtostr + presCartstr
        self.send_with_socket(mes)
        
        return 

    def send_with_socket(self, mes):
        """
        Sends a message through the socket.

        :param mes: Message to be sent
        :type mes: str
        """
        self.client.sendall(mes.encode('utf-8'))
        return 


    def stop_print(self):
        """
        Turns off all solenoids and sends an update if the print process is stopped without terminating the C process.
        """
        self.st_ato=0
        self.st_cart=0
        self.st_point=0
        self.sendToClient(1)